#!/usr/bin/env node

/**
 * ë¬¸ì„œ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸ (Document Linter)
 * 
 * ê²€ì¦ í•­ëª©:
 * 1. íŒŒì¼ ë„¤ì´ë°: kebab-case (ì†Œë¬¸ì + í•˜ì´í”ˆ)
 * 2. Changelog ì„¹ì…˜: ìˆ˜ë™ ë¬¸ì„œì— í•„ìˆ˜
 * 3. ë¬¸ì„œ ìœ„ì¹˜: í—ˆìš©ëœ ë””ë ‰í† ë¦¬ êµ¬ì¡°
 * 4. í•„ìˆ˜ í—¤ë”: ì œëª© (H1)
 * 
 * ì‚¬ìš©ë²•:
 *   node scripts/check-docs.js [files...]
 *   node scripts/check-docs.js --all
 */

const fs = require('fs');
const path = require('path');

// ============================================================
// ì„¤ì •
// ============================================================

const DOCS_ROOT = path.join(__dirname, '..', 'docs');

// ìë™ ìƒì„± ë¬¸ì„œ ê²½ë¡œ (Changelog ê²€ì¦ ì œì™¸)
const AUTO_GENERATED_PATHS = [
  /\/reference\//,    // ëª¨ë“  reference/ í´ë”
  /^CHANGELOG\.md$/,  // ë£¨íŠ¸ CHANGELOG
];

// Changelog ê²€ì¦ ì œì™¸ ê²½ë¡œ
const CHANGELOG_EXEMPT_PATHS = [
  /\/_archive\//,     // ì•„ì¹´ì´ë¸Œ í´ë”
  /\/reference\//,    // ìë™ ìƒì„± í´ë”
];

// í—ˆìš©ëœ ë””ë ‰í† ë¦¬ êµ¬ì¡°
const ALLOWED_DIRECTORIES = {
  // ë„ë©”ì¸ë³„ (pms, dms, common)
  domain: [
    'architecture',  // ì•„í‚¤í…ì²˜ ê²°ì •, í‘œì¤€
    'design',        // UI/UX ì„¤ê³„
    'domain',        // ë¹„ì¦ˆë‹ˆìŠ¤ ê°œë…
    'guides',        // ê°€ì´ë“œë¼ì¸
    'planning',      // ë°±ë¡œê·¸, ë¡œë“œë§µ, ì²´ì¸ì§€ë¡œê·¸
    'tests',         // í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
    'reference',     // ìë™ ìƒì„± (api, db, typedoc, storybook)
    '_archive',      // ì•„ì¹´ì´ë¸Œ
  ],
  // ê³µí†µ (common ì „ìš©)
  common: [
    'architecture',
    'guides', 
    'reference',
  ],
};

// íŒŒì¼ ë„¤ì´ë° íŒ¨í„´
const FILE_NAME_PATTERN = /^[a-z0-9]+(-[a-z0-9]+)*\.md$/;
const README_PATTERN = /^README\.md$/;
const ADR_PATTERN = /^adr-\d{3}-[a-z0-9]+(-[a-z0-9]+)*\.md$/;
// íŠ¹ìˆ˜ íŒŒì¼ (ëŒ€ë¬¸ì í—ˆìš©)
const SPECIAL_FILES = ['CHANGELOG.md', 'AGENTS.md', 'README.md', 'LICENSE.md'];

// ============================================================
// ìœ í‹¸ë¦¬í‹°
// ============================================================

const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const GREEN = '\x1b[32m';
const RESET = '\x1b[0m';

function isAutoGenerated(filePath) {
  const relativePath = path.relative(DOCS_ROOT, filePath);
  return AUTO_GENERATED_PATHS.some(pattern => pattern.test(relativePath));
}

function getRelativePath(filePath) {
  const projectRoot = path.join(__dirname, '..');
  return path.relative(projectRoot, filePath);
}

// ============================================================
// ê²€ì¦ í•¨ìˆ˜
// ============================================================

/**
 * íŒŒì¼ ë„¤ì´ë° ê²€ì¦ (kebab-case)
 */
function checkFileName(filePath) {
  const fileName = path.basename(filePath);
  const errors = [];

  // íŠ¹ìˆ˜ íŒŒì¼ í—ˆìš© (README, CHANGELOG, AGENTS ë“±)
  if (SPECIAL_FILES.includes(fileName)) {
    return errors;
  }

  // _archive í´ë”ëŠ” ë„¤ì´ë° ê·œì¹™ ì™„í™”
  if (filePath.includes('/_archive/')) {
    return errors;
  }

  // ADR íŒ¨í„´ í™•ì¸
  if (fileName.startsWith('adr-')) {
    if (!ADR_PATTERN.test(fileName)) {
      errors.push({
        type: 'naming',
        message: `ADR íŒŒì¼ì€ 'adr-NNN-description.md' í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤: ${fileName}`,
        severity: 'error',
      });
    }
    return errors;
  }

  // ì¼ë°˜ íŒŒì¼ kebab-case í™•ì¸
  if (!FILE_NAME_PATTERN.test(fileName)) {
    errors.push({
      type: 'naming',
      message: `íŒŒì¼ëª…ì€ kebab-case (ì†Œë¬¸ì + í•˜ì´í”ˆ)ì—¬ì•¼ í•©ë‹ˆë‹¤: ${fileName}`,
      severity: 'error',
    });
  }

  return errors;
}

/**
 * Changelog ì„¹ì…˜ ê²€ì¦
 */
function checkChangelog(filePath, content) {
  const errors = [];
  const relativePath = path.relative(DOCS_ROOT, filePath);

  // ìë™ ìƒì„± ë¬¸ì„œ ë° ì•„ì¹´ì´ë¸ŒëŠ” ì œì™¸
  if (isAutoGenerated(filePath) || 
      CHANGELOG_EXEMPT_PATHS.some(p => p.test(relativePath))) {
    return errors;
  }

  // README.md, CHANGELOG.md, AGENTS.mdëŠ” Changelog í•„ìˆ˜ ì•„ë‹˜
  const fileName = path.basename(filePath);
  if (SPECIAL_FILES.includes(fileName)) {
    return errors;
  }

  // Changelog ì„¹ì…˜ í™•ì¸
  const hasChangelog = /^##\s*Changelog/m.test(content) || 
                       /^\| ë‚ ì§œ \| ë³€ê²½ ë‚´ìš© \|/m.test(content);

  if (!hasChangelog) {
    errors.push({
      type: 'changelog',
      message: 'Changelog ì„¹ì…˜ì´ í•„ìš”í•©ë‹ˆë‹¤ (## Changelog)',
      severity: 'warning',
    });
  }

  return errors;
}

/**
 * í•„ìˆ˜ í—¤ë” ê²€ì¦ (H1 ì œëª©)
 */
function checkHeader(filePath, content) {
  const errors = [];

  // H1 í—¤ë” í™•ì¸
  const hasH1 = /^#\s+.+/m.test(content);

  if (!hasH1) {
    errors.push({
      type: 'header',
      message: 'H1 ì œëª©(# ì œëª©)ì´ í•„ìš”í•©ë‹ˆë‹¤',
      severity: 'error',
    });
  }

  return errors;
}

/**
 * ë¬¸ì„œ ìœ„ì¹˜ ê²€ì¦
 */
function checkLocation(filePath) {
  const errors = [];
  const relativePath = path.relative(DOCS_ROOT, filePath);
  const parts = relativePath.split(path.sep);

  // docs/ ë£¨íŠ¸ íŒŒì¼ì€ í—ˆìš© (CHANGELOG.md, README.md, getting-started.md)
  if (parts.length === 1) {
    return errors;
  }

  // ë„ë©”ì¸ ë£¨íŠ¸ì˜ README.md í—ˆìš© (docs/pms/README.md)
  if (parts.length === 2 && parts[1] === 'README.md') {
    return errors;
  }

  // common ë£¨íŠ¸ì˜ íŠ¹ìˆ˜ íŒŒì¼ í—ˆìš© (AGENTS.md)
  if (parts.length === 2 && parts[0] === 'common' && SPECIAL_FILES.includes(parts[1])) {
    return errors;
  }

  const domain = parts[0]; // common, pms, dms
  const directory = parts[1]; // architecture, design, etc.

  // ë„ë©”ì¸ í™•ì¸
  if (!['common', 'pms', 'dms'].includes(domain)) {
    errors.push({
      type: 'location',
      message: `ì•Œ ìˆ˜ ì—†ëŠ” ë„ë©”ì¸: ${domain} (common, pms, dmsë§Œ í—ˆìš©)`,
      severity: 'error',
    });
    return errors;
  }

  // ë””ë ‰í† ë¦¬ í™•ì¸
  const allowedDirs = domain === 'common' 
    ? ALLOWED_DIRECTORIES.common 
    : ALLOWED_DIRECTORIES.domain;

  if (!allowedDirs.includes(directory)) {
    errors.push({
      type: 'location',
      message: `í—ˆìš©ë˜ì§€ ì•Šì€ ë””ë ‰í† ë¦¬: ${directory} (í—ˆìš©: ${allowedDirs.join(', ')})`,
      severity: 'error',
    });
  }

  return errors;
}

/**
 * íŒŒì¼ í•˜ë‚˜ ê²€ì¦
 */
function validateFile(filePath) {
  const errors = [];

  // ë§ˆí¬ë‹¤ìš´ íŒŒì¼ë§Œ
  if (!filePath.endsWith('.md')) {
    return { filePath, errors: [], skipped: true };
  }

  // íŒŒì¼ ì½ê¸°
  let content;
  try {
    content = fs.readFileSync(filePath, 'utf-8');
  } catch (e) {
    errors.push({
      type: 'read',
      message: `íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${e.message}`,
      severity: 'error',
    });
    return { filePath, errors };
  }

  // ê²€ì¦ ìˆ˜í–‰
  errors.push(...checkFileName(filePath));
  errors.push(...checkHeader(filePath, content));
  errors.push(...checkChangelog(filePath, content));
  errors.push(...checkLocation(filePath));

  return { filePath, errors };
}

/**
 * ëª¨ë“  ë¬¸ì„œ íŒŒì¼ ì°¾ê¸°
 */
function findAllDocs() {
  const files = [];
  
  function walk(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        // node_modules, .git ë“± ì œì™¸
        if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {
          walk(fullPath);
        }
      } else if (entry.name.endsWith('.md')) {
        files.push(fullPath);
      }
    }
  }
  
  walk(DOCS_ROOT);
  return files;
}

// ============================================================
// ë©”ì¸
// ============================================================

function main() {
  const args = process.argv.slice(2);
  let files;

  if (args.includes('--all') || args.length === 0) {
    files = findAllDocs();
  } else {
    // ì œê³µëœ íŒŒì¼ë§Œ ê²€ì¦
    files = args
      .filter(f => f.endsWith('.md'))
      .map(f => path.resolve(f))
      .filter(f => fs.existsSync(f));
  }

  if (files.length === 0) {
    console.log('ê²€ì¦í•  ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.');
    process.exit(0);
  }

  console.log(`\nğŸ“„ ë¬¸ì„œ ê²€ì¦: ${files.length}ê°œ íŒŒì¼\n`);

  let totalErrors = 0;
  let totalWarnings = 0;
  const results = [];

  for (const file of files) {
    const result = validateFile(file);
    if (result.skipped) continue;

    const fileErrors = result.errors.filter(e => e.severity === 'error');
    const fileWarnings = result.errors.filter(e => e.severity === 'warning');

    totalErrors += fileErrors.length;
    totalWarnings += fileWarnings.length;

    if (result.errors.length > 0) {
      results.push(result);
    }
  }

  // ê²°ê³¼ ì¶œë ¥
  for (const result of results) {
    console.log(`${getRelativePath(result.filePath)}`);
    for (const error of result.errors) {
      const color = error.severity === 'error' ? RED : YELLOW;
      const icon = error.severity === 'error' ? 'âœ—' : 'âš ';
      console.log(`  ${color}${icon} [${error.type}] ${error.message}${RESET}`);
    }
    console.log();
  }

  // ìš”ì•½
  console.log('â”€'.repeat(50));
  if (totalErrors === 0 && totalWarnings === 0) {
    console.log(`${GREEN}âœ“ ëª¨ë“  ë¬¸ì„œ ê²€ì¦ í†µê³¼${RESET}`);
  } else {
    console.log(`ê²°ê³¼: ${RED}${totalErrors} ì—ëŸ¬${RESET}, ${YELLOW}${totalWarnings} ê²½ê³ ${RESET}`);
  }

  // ì—ëŸ¬ê°€ ìˆìœ¼ë©´ ì¢…ë£Œ ì½”ë“œ 1
  process.exit(totalErrors > 0 ? 1 : 0);
}

main();
