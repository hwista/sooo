# ğŸ—ï¸ Phase 1.2.2 API ë ˆì´ì–´ ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

**ì„¤ê³„ ì¼ì‹œ**: 2025-01-20  
**ê¸°ì¤€ ë¬¸ì„œ**: 1.2.1-analysis.md  
**ë¸Œëœì¹˜**: refactor/v1  

---

## ğŸ¯ ì„¤ê³„ ëª©í‘œ

1. **ì¤‘ë³µ ì œê±°**: 15+ API í˜¸ì¶œ ë¡œì§ â†’ ì¤‘ì•™í™”ëœ ì„œë¹„ìŠ¤ ë ˆì´ì–´
2. **ê´€ì‹¬ì‚¬ ë¶„ë¦¬**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ UI ë¡œì§ ë¶„ë¦¬
3. **í…ŒìŠ¤íŠ¸ ìš©ì´ì„±**: ëª¨í‚¹ ê°€ëŠ¥í•œ ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤
4. **íƒ€ì… ì•ˆì „ì„±**: ê¸°ì¡´ íƒ€ì… ì‹œìŠ¤í…œê³¼ ì™„ë²½ í˜¸í™˜

---

## ğŸ“ services/ í´ë” êµ¬ì¡° ì„¤ê³„

### **ìµœì¢… êµ¬ì¡°**
```
services/
â”œâ”€â”€ index.ts                    # í†µí•© export
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ BaseService.ts         # ê¸°ë³¸ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
â”‚   â”œâ”€â”€ ServiceConfig.ts       # ì„œë¹„ìŠ¤ ì„¤ì • íƒ€ì…
â”‚   â””â”€â”€ ServiceEvents.ts       # ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
â”œâ”€â”€ fileSystem/
â”‚   â”œâ”€â”€ FileSystemService.ts   # íŒŒì¼ ì‹œìŠ¤í…œ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ FileTreeService.ts     # íŒŒì¼ íŠ¸ë¦¬ ê´€ë¦¬
â”‚   â””â”€â”€ FileWatchService.ts    # ì‹¤ì‹œê°„ ê°ì‹œ
â””â”€â”€ types/
    â”œâ”€â”€ ServiceTypes.ts        # ì„œë¹„ìŠ¤ ì „ìš© íƒ€ì…
    â””â”€â”€ EventTypes.ts          # ì´ë²¤íŠ¸ íƒ€ì…
```

---

## ğŸ› ï¸ ì„œë¹„ìŠ¤ ë ˆì´ì–´ ì•„í‚¤í…ì²˜ ì„¤ê³„

### **Layer 1: ê¸°ë³¸ HTTP í´ë¼ì´ì–¸íŠ¸** (ê¸°ì¡´ ìœ ì§€)
```typescript
// utils/apiClient.ts - ì´ë¯¸ ì˜ êµ¬í˜„ë¨
â”œâ”€â”€ request() - HTTP ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬
â”œâ”€â”€ fileApi - íŒŒì¼ API ì—”ë“œí¬ì¸íŠ¸
â””â”€â”€ filesApi - íŒŒì¼ ëª©ë¡ API ì—”ë“œí¬ì¸íŠ¸
```

### **ğŸ¯ Layer 2: ë„ë©”ì¸ ì„œë¹„ìŠ¤** (ìƒˆë¡œ êµ¬ì¶•)
```typescript
// services/fileSystem/FileSystemService.ts
interface IFileSystemService {
  // íŒŒì¼ ì‘ì—…
  createFile(path: string, content: string): Promise<ServiceResult<void>>;
  readFile(path: string): Promise<ServiceResult<string>>;
  updateFile(path: string, content: string): Promise<ServiceResult<void>>;
  deleteFile(path: string): Promise<ServiceResult<void>>;
  
  // í´ë” ì‘ì—…
  createFolder(path: string): Promise<ServiceResult<void>>;
  renameItem(oldPath: string, newPath: string): Promise<ServiceResult<void>>;
  
  // ì´ë²¤íŠ¸
  on(event: FileSystemEvent, handler: EventHandler): void;
  off(event: FileSystemEvent, handler: EventHandler): void;
}
```

### **ğŸ¯ Layer 3: ìƒíƒœ ê´€ë¦¬ í›…** (ê°œì„ )
```typescript
// hooks/useFileSystemService.ts
interface UseFileSystemResult {
  // ìƒíƒœ
  loading: boolean;
  error: string | null;
  
  // ì‘ì—… í•¨ìˆ˜
  createFile: (path: string, content: string) => Promise<void>;
  readFile: (path: string) => Promise<string | null>;
  updateFile: (path: string, content: string) => Promise<void>;
  deleteFile: (path: string) => Promise<void>;
  
  // ìœ í‹¸ë¦¬í‹°
  clearError: () => void;
  retry: () => Promise<void>;
}
```

---

## ğŸ”§ í•µì‹¬ íƒ€ì… ì •ì˜

### **1. ì„œë¹„ìŠ¤ ê²°ê³¼ íƒ€ì…**
```typescript
// services/types/ServiceTypes.ts
export interface ServiceResult<T = void> {
  success: boolean;
  data?: T;
  error?: ServiceError;
  metadata?: ServiceMetadata;
}

export interface ServiceError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  cause?: Error;
}

export interface ServiceMetadata {
  timestamp: number;
  duration?: number;
  requestId?: string;
  context?: Record<string, unknown>;
}
```

### **2. ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ íƒ€ì…**
```typescript
// services/types/EventTypes.ts
export type FileSystemEvent = 
  | 'file:created'
  | 'file:updated'
  | 'file:deleted'
  | 'file:renamed'
  | 'folder:created'
  | 'folder:deleted'
  | 'tree:refreshed';

export interface FileSystemEventData {
  path: string;
  type: 'file' | 'folder';
  oldPath?: string; // rename ì´ë²¤íŠ¸ìš©
  timestamp: number;
}

export type EventHandler<T = FileSystemEventData> = (data: T) => void;
```

### **3. ì„œë¹„ìŠ¤ ì„¤ì • íƒ€ì…**
```typescript
// services/base/ServiceConfig.ts
export interface ServiceConfig {
  // API ì„¤ì •
  baseUrl?: string;
  timeout?: number;
  retries?: number;
  
  // ë¡œê¹… ì„¤ì •
  enableLogging?: boolean;
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
  
  // ìºì‹± ì„¤ì •
  enableCaching?: boolean;
  cacheTtl?: number;
  
  // ì´ë²¤íŠ¸ ì„¤ì •
  enableEvents?: boolean;
  maxEventListeners?: number;
}
```

---

## ğŸ›ï¸ ê¸°ë³¸ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ ì„¤ê³„

### **BaseService ì¶”ìƒ í´ë˜ìŠ¤**
```typescript
// services/base/BaseService.ts
export abstract class BaseService {
  protected config: ServiceConfig;
  protected events: EventEmitter;
  protected logger: Logger;
  
  constructor(config: ServiceConfig = {}) {
    this.config = { ...defaultConfig, ...config };
    this.events = new EventEmitter();
    this.logger = createLogger(this.config.logLevel);
  }
  
  // ì´ë²¤íŠ¸ ê´€ë¦¬
  protected emit<T>(event: string, data: T): void {
    if (this.config.enableEvents) {
      this.events.emit(event, data);
    }
  }
  
  public on<T>(event: string, handler: EventHandler<T>): void {
    this.events.on(event, handler);
  }
  
  public off<T>(event: string, handler: EventHandler<T>): void {
    this.events.off(event, handler);
  }
  
  // ê³µí†µ ì—ëŸ¬ ì²˜ë¦¬
  protected handleError(error: unknown, context: string): ServiceError {
    const serviceError: ServiceError = {
      code: this.getErrorCode(error),
      message: this.getErrorMessage(error),
      details: { context, timestamp: Date.now() }
    };
    
    this.logger.error('ì„œë¹„ìŠ¤ ì—ëŸ¬', serviceError);
    return serviceError;
  }
  
  // ì„±ëŠ¥ ì¸¡ì •
  protected async executeWithTiming<T>(
    operation: () => Promise<T>,
    operationName: string
  ): Promise<ServiceResult<T>> {
    const timer = new PerformanceTimer(operationName);
    
    try {
      const result = await operation();
      const duration = timer.end();
      
      return {
        success: true,
        data: result,
        metadata: {
          timestamp: Date.now(),
          duration,
          context: { operation: operationName }
        }
      };
    } catch (error) {
      timer.end();
      return {
        success: false,
        error: this.handleError(error, operationName)
      };
    }
  }
}
```

---

## ğŸ“ FileSystemService ìƒì„¸ ì„¤ê³„

### **í•µì‹¬ ì¸í„°í˜ì´ìŠ¤**
```typescript
// services/fileSystem/FileSystemService.ts
export interface IFileSystemService {
  // íŒŒì¼ ì‘ì—…
  createFile(path: string, content: string, options?: CreateFileOptions): Promise<ServiceResult<void>>;
  readFile(path: string, options?: ReadFileOptions): Promise<ServiceResult<string>>;
  updateFile(path: string, content: string, options?: UpdateFileOptions): Promise<ServiceResult<void>>;
  deleteFile(path: string, options?: DeleteFileOptions): Promise<ServiceResult<void>>;
  
  // í´ë” ì‘ì—…
  createFolder(path: string, options?: CreateFolderOptions): Promise<ServiceResult<void>>;
  renameItem(oldPath: string, newPath: string, options?: RenameOptions): Promise<ServiceResult<void>>;
  
  // ê²€ì¦ ë° ìœ í‹¸ë¦¬í‹°
  validatePath(path: string): ValidationResult;
  exists(path: string): Promise<ServiceResult<boolean>>;
  getInfo(path: string): Promise<ServiceResult<FileMetadata>>;
}

// ì‘ì—… ì˜µì…˜ íƒ€ì…ë“¤
export interface CreateFileOptions {
  overwrite?: boolean;
  createParentFolders?: boolean;
  template?: string;
}

export interface ReadFileOptions {
  encoding?: 'utf-8' | 'base64';
  useCache?: boolean;
}

export interface UpdateFileOptions {
  createBackup?: boolean;
  validateContent?: boolean;
}

export interface DeleteFileOptions {
  force?: boolean;
  moveToTrash?: boolean;
}
```

### **êµ¬í˜„ í´ë˜ìŠ¤**
```typescript
export class FileSystemService extends BaseService implements IFileSystemService {
  constructor(config?: ServiceConfig) {
    super(config);
  }
  
  async createFile(
    path: string, 
    content: string, 
    options: CreateFileOptions = {}
  ): Promise<ServiceResult<void>> {
    return this.executeWithTiming(async () => {
      // 1. ê²½ë¡œ ê²€ì¦
      const validation = this.validatePath(path);
      if (!validation.valid) {
        throw new Error(`Invalid path: ${validation.errors.join(', ')}`);
      }
      
      // 2. ì¤‘ë³µ ì²´í¬ (overwrite ì˜µì…˜ ê³ ë ¤)
      if (!options.overwrite) {
        const existsResult = await this.exists(path);
        if (existsResult.success && existsResult.data) {
          throw new Error(`File already exists: ${path}`);
        }
      }
      
      // 3. ë¶€ëª¨ í´ë” ìƒì„± (í•„ìš”ì‹œ)
      if (options.createParentFolders) {
        await this.createParentFolders(path);
      }
      
      // 4. API í˜¸ì¶œ
      const response = await fileApi.create(path, content);
      if (!response.success) {
        throw new Error(response.error || 'File creation failed');
      }
      
      // 5. ì´ë²¤íŠ¸ ë°œí–‰
      this.emit('file:created', {
        path,
        type: 'file',
        timestamp: Date.now()
      });
      
      // 6. ìºì‹œ ë¬´íš¨í™” (ìˆë‹¤ë©´)
      this.invalidateCache(path);
      
    }, 'createFile');
  }
  
  async readFile(
    path: string, 
    options: ReadFileOptions = {}
  ): Promise<ServiceResult<string>> {
    return this.executeWithTiming(async () => {
      // 1. ìºì‹œ í™•ì¸
      if (options.useCache && this.config.enableCaching) {
        const cached = this.getFromCache(path);
        if (cached) {
          return cached;
        }
      }
      
      // 2. API í˜¸ì¶œ
      const response = await fileApi.read(path);
      if (!response.success) {
        throw new Error(response.error || 'File read failed');
      }
      
      // 3. ìºì‹œ ì €ì¥
      if (this.config.enableCaching) {
        this.saveToCache(path, response.data);
      }
      
      return response.data;
    }, 'readFile');
  }
  
  // ... ë‹¤ë¥¸ ë©”ì„œë“œë“¤ë„ ìœ ì‚¬í•œ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„
}
```

---

## ğŸŒ³ FileTreeService ì„¤ê³„

### **íŠ¸ë¦¬ ê´€ë¦¬ ì „ìš© ì„œë¹„ìŠ¤**
```typescript
// services/fileSystem/FileTreeService.ts
export interface IFileTreeService {
  // íŠ¸ë¦¬ ì¡°íšŒ
  getTree(path?: string, options?: GetTreeOptions): Promise<ServiceResult<FileTree>>;
  refreshTree(path?: string): Promise<ServiceResult<FileTree>>;
  
  // íŠ¸ë¦¬ ì¡°ì‘
  expandNode(path: string): Promise<ServiceResult<void>>;
  collapseNode(path: string): Promise<ServiceResult<void>>;
  
  // ê²€ìƒ‰ ë° í•„í„°ë§
  searchTree(query: string, options?: SearchOptions): Promise<ServiceResult<FileNode[]>>;
  filterTree(predicate: (node: FileNode) => boolean): Promise<ServiceResult<FileTree>>;
  
  // ìƒíƒœ ê´€ë¦¬
  getExpandedNodes(): Set<string>;
  setExpandedNodes(paths: Set<string>): void;
  
  // ìºì‹œ ê´€ë¦¬
  clearCache(): void;
  preloadTree(paths: string[]): Promise<ServiceResult<void>>;
}

export interface GetTreeOptions {
  depth?: number;
  includeHidden?: boolean;
  sortBy?: 'name' | 'type' | 'date';
  sortOrder?: 'asc' | 'desc';
}

export interface SearchOptions {
  caseSensitive?: boolean;
  includeContent?: boolean;
  fileTypes?: string[];
  maxResults?: number;
}
```

---

## ğŸ”„ ì´ë²¤íŠ¸ ê¸°ë°˜ ìƒíƒœ ë™ê¸°í™”

### **ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„**
```typescript
// services/base/ServiceEvents.ts
export class ServiceEventBus {
  private static instance: ServiceEventBus;
  private events: Map<string, EventHandler[]>;
  
  static getInstance(): ServiceEventBus {
    if (!ServiceEventBus.instance) {
      ServiceEventBus.instance = new ServiceEventBus();
    }
    return ServiceEventBus.instance;
  }
  
  // ì´ë²¤íŠ¸ ë°œí–‰
  emit<T>(event: string, data: T): void {
    const handlers = this.events.get(event) || [];
    handlers.forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error(`Event handler error for ${event}:`, error);
      }
    });
  }
  
  // ì´ë²¤íŠ¸ êµ¬ë…
  on<T>(event: string, handler: EventHandler<T>): () => void {
    const handlers = this.events.get(event) || [];
    handlers.push(handler);
    this.events.set(event, handlers);
    
    // êµ¬ë… í•´ì œ í•¨ìˆ˜ ë°˜í™˜
    return () => this.off(event, handler);
  }
  
  // êµ¬ë… í•´ì œ
  off<T>(event: string, handler: EventHandler<T>): void {
    const handlers = this.events.get(event) || [];
    const index = handlers.indexOf(handler);
    if (index > -1) {
      handlers.splice(index, 1);
      this.events.set(event, handlers);
    }
  }
}
```

### **React Hook í†µí•©**
```typescript
// hooks/useFileSystemService.ts
export const useFileSystemService = (): UseFileSystemResult => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fileSystemService = useMemo(() => 
    new FileSystemService({ enableEvents: true }), []
  );
  
  // ì´ë²¤íŠ¸ êµ¬ë…
  useEffect(() => {
    const unsubscribeCreate = fileSystemService.on('file:created', (data) => {
      // íŒŒì¼ ìƒì„± í›„ ì²˜ë¦¬ ë¡œì§
      showNotification('success', 'íŒŒì¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', data.path);
    });
    
    const unsubscribeError = fileSystemService.on('error', (error) => {
      setError(error.message);
    });
    
    return () => {
      unsubscribeCreate();
      unsubscribeError();
    };
  }, [fileSystemService]);
  
  // ì‘ì—… í•¨ìˆ˜ë“¤
  const createFile = useCallback(async (path: string, content: string) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await fileSystemService.createFile(path, content);
      if (!result.success) {
        throw new Error(result.error?.message || 'File creation failed');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      throw err;
    } finally {
      setLoading(false);
    }
  }, [fileSystemService]);
  
  return {
    loading,
    error,
    createFile,
    readFile: /* ... */,
    updateFile: /* ... */,
    deleteFile: /* ... */,
    clearError: () => setError(null),
    retry: /* ... */
  };
};
```

---

## ğŸ¯ ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

### **Phase 1: ê¸°ë³¸ êµ¬ì¡° êµ¬ì¶• (1ì¼)**
1. services/ í´ë” ìƒì„±
2. BaseService, ServiceConfig, ServiceEvents êµ¬í˜„
3. FileSystemService ê¸°ë³¸ ê³¨ê²© êµ¬í˜„

### **Phase 2: í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„ (1-2ì¼)**
1. FileSystemService ëª¨ë“  ë©”ì„œë“œ êµ¬í˜„
2. FileTreeService êµ¬í˜„
3. React Hook í†µí•©

### **Phase 3: ì ì§„ì  ì ìš© (1ì¼)**
1. app/wiki/page.tsx ìš°ì„  ì ìš©
2. hooks/useFileOperations.ts ë§ˆì´ê·¸ë ˆì´ì…˜
3. ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

---

## âœ… ì„¤ê³„ ì›ì¹™

### **1. ë‹¨ì¼ ì±…ì„ ì›ì¹™**
- FileSystemService: íŒŒì¼/í´ë” CRUD
- FileTreeService: íŠ¸ë¦¬ êµ¬ì¡° ê´€ë¦¬
- ServiceEventBus: ì´ë²¤íŠ¸ ì¤‘ì¬

### **2. ì˜ì¡´ì„± ì—­ì „ ì›ì¹™**
- ì„œë¹„ìŠ¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´
- Hookì€ ì„œë¹„ìŠ¤ êµ¬í˜„ì— ì˜ì¡´
- í…ŒìŠ¤íŠ¸ ì‹œ ëª¨í‚¹ ìš©ì´

### **3. ì—´ë¦¼/ë‹«í˜ ì›ì¹™**
- ìƒˆë¡œìš´ íŒŒì¼ ì‹œìŠ¤í…œ ê¸°ëŠ¥ ì‰½ê²Œ ì¶”ê°€
- ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ ë³€ê²½ ì—†ì´ í™•ì¥ ê°€ëŠ¥

### **4. ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™**
- ëª¨ë“  ì„œë¹„ìŠ¤ëŠ” BaseService êµì²´ ê°€ëŠ¥
- ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì²´ ììœ  êµì²´ ê°€ëŠ¥

---

## ğŸ”„ ë‹¤ìŒ ë‹¨ê³„

**Phase 1.2.3 services/ í´ë” êµ¬ì¡° ìƒì„±**ìœ¼ë¡œ ì§„í–‰í•˜ì—¬ ì„¤ê³„ëœ êµ¬ì¡°ë¥¼ ì‹¤ì œë¡œ êµ¬í˜„í•˜ê² ìŠµë‹ˆë‹¤.